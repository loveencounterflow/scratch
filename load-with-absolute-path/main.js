// Generated by CoffeeScript 1.9.1
(function() {
  var $, $async, ASYNC, CND, CS, D, SEMVER, alert, badge, debug, echo, help, info, log, njs_cp, njs_fs, njs_os, njs_path, options_route, rpr, step, suspend, urge, warn, whisper;

  njs_path = require('path');

  njs_fs = require('fs');

  njs_os = require('os');

  njs_cp = require('child_process');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'jizura-load-with-absolute-paths';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  ASYNC = require('async');

  SEMVER = require('semver');

  CS = require('coffee-script');

  options_route = './options.coffee';

  this.options = null;

  this._eval_coffee_file = function(route) {
    var rqr_route, source;
    rqr_route = require.resolve(route);
    source = njs_fs.readFileSync(rqr_route, {
      encoding: 'utf-8'
    });
    return CS["eval"](source, {
      bare: true
    });
  };

  this._update_cache = function() {
    var cache, sys_cache, sysid;
    cache = this.options['cache']['%self'];
    cache['sysid'] = sysid = this._get_sysid();
    if (cache[sysid] == null) {
      sys_cache = {};
      cache[sysid] = sys_cache;
    }
    return this._save_cache();
  };

  this._set_cache = function(key, value, save) {
    var target;
    if (save == null) {
      save = true;
    }
    target = this.options['cache']['%self'][this.options['cache']['%self']['sysid']];
    target[key] = value;
    if (save != null) {
      this._save_cache();
    }
    return null;
  };

  this._get_cache = function(key, method, save, handler) {
    var R, cache, sysid, target;
    if (save == null) {
      save = true;
    }
    if (handler == null) {
      handler = null;
    }
    cache = this.options['cache']['%self'];
    sysid = cache['sysid'];
    target = cache[sysid];
    R = target[key];
    if (handler != null) {
      if (R === void 0) {
        return method((function(_this) {
          return function(error, R) {
            if (error != null) {
              return handler(error);
            }
            _this._set_cache(key, R, save);
            return handler(null, R);
          };
        })(this));
      } else {
        return handler(null, R);
      }
    } else {
      if (R === void 0) {
        this._set_cache(key, (R = method()), save);
      }
      return R;
    }
  };

  this._save_cache = function() {
    var cache, locator;
    locator = this.options['cache']['locator'];
    cache = this.options['cache']['%self'];
    return njs_fs.writeFileSync(locator, JSON.stringify(cache, null, '  '));
  };

  this._get_sysid = function() {
    return (njs_os.hostname()) + ":" + (njs_os.platform());
  };

  this._compile_options = function() {

    /* TAINT code duplication */

    /* TAINT must insert '../' when used from `lib/` */
    var cache_locator, cache_route, fonts_locator, fonts_route;
    this.options = this._eval_coffee_file(options_route);
    cache_route = this.options['cache']['route'];
    this.options['cache']['locator'] = cache_locator = njs_path.resolve(__dirname, cache_route);
    if (!njs_fs.existsSync(cache_locator)) {
      this.options['cache']['%self'] = {};
      this._save_cache();
    }
    this.options['cache']['%self'] = require(cache_locator);
    fonts_route = this.options['fonts']['route'];
    this.options['fonts']['locator'] = fonts_locator = njs_path.resolve(__dirname, fonts_route);
    return this._update_cache();
  };

  this._compile_options();

  this.write_font_declarations = function(handler) {
    return step((function(_this) {
      return function*(resume) {
        var filename, fonts_locator, fontspec_version, home, i, len, lines, ref, ref1, texname, use_new_syntax;
        fontspec_version = (yield _this.read_texlive_package_version('fontspec', resume));
        fonts_locator = _this.options['fonts']['locator'];
        help("writing " + fonts_locator);
        help("for fontspec@" + fontspec_version);
        use_new_syntax = SEMVER.satisfies(fontspec_version, '>=2.4.0');
        lines = [];
        ref = _this.options['fonts']['declarations'];
        for (i = 0, len = ref.length; i < len; i++) {
          ref1 = ref[i], texname = ref1.texname, home = ref1.home, filename = ref1.filename;
          if (use_new_syntax) {

            /* TAINT should properly escape values */
            lines.push("\\newfontface\\" + texname + "{" + filename + "}[Path=\\" + home + "/]");
          } else {
            lines.push("\\newfontface\\" + texname + "[Path=\\" + home + "/]{" + filename + "}");
          }
        }
        return njs_fs.writeFile(fonts_locator, lines.join('\n'), handler);
      };
    })(this));
  };

  this.read_texlive_package_version = function(package_name, handler) {
    var key, method;
    key = "texlive-package-versions/" + package_name;
    method = (function(_this) {
      return function(done) {
        return _this._read_texlive_package_version(package_name, done);
      };
    })(this);
    this._get_cache(key, method, true, handler);
    return null;
  };

  this._read_texlive_package_version = function(package_name, handler) {

    /* Given a `package_name` and a `handler`, try to retrieve that package's info as reported by the TeX
    Live Manager command line tool (using `tlmgr info ${package_name}`), extract the `cat-version` entry and
    normalize it so it matches the [Semantic Versioning specs](http://semver.org/). If no version is found,
    the `handler` will be called with a `null` value instead of a string; however, if a version *is* found but
    does *not* match the SemVer specs after normalization, the `handler` will be called with an error.
    
    Normalization steps include removing leading `v`s, trailing letters, and leading zeroes.
     */
    var leading_zero_pattern, semver_pattern;
    leading_zero_pattern = /^0+(?!$)/;
    semver_pattern = /^([0-9]+)\.([0-9]+)\.?([0-9]*)$/;
    this.read_texlive_package_info(package_name, (function(_this) {
      return function(error, package_info) {
        var _, major, match, minor, o_version, patch, version;
        if (error != null) {
          return handler(error);
        }
        if ((version = o_version = package_info['cat-version']) == null) {
          warn("unable to detect version for package " + (rpr(package_name)));
          return handler(null, null);
        }
        version = version.replace(/[^0-9]+$/, '');
        version = version.replace(/^v/, '');
        if ((match = version.match(semver_pattern)) == null) {
          return handler(new Error("unable to parse version " + (rpr(o_version)) + " of package " + (rpr(name))));
        }
        _ = match[0], major = match[1], minor = match[2], patch = match[3];

        /* thx to http://stackoverflow.com/a/2800839/256361 */
        major = major.replace(leading_zero_pattern, '');
        minor = minor.replace(leading_zero_pattern, '');
        patch = patch.replace(leading_zero_pattern, '');
        major = major.length > 0 ? major : '0';
        minor = minor.length > 0 ? minor : '0';
        patch = patch.length > 0 ? patch : '0';
        return handler(null, major + "." + minor + "." + patch);
      };
    })(this));
    return null;
  };

  this.read_texlive_package_info = function(package_name, handler) {
    var Z, command, input, parameters, pattern;
    command = 'tlmgr';
    parameters = ['info', package_name];
    input = D.spawn_and_read_lines(command, parameters);
    Z = {};
    pattern = /^([^:]+):(.*)$/;
    input.pipe($((function(_this) {
      return function(line, send) {
        var _, match, name, value;
        if (line.length === 0) {
          return;
        }
        match = line.match(pattern);
        if (match == null) {
          return send.error(new Error("unexpected line: " + (rpr(line))));
        }
        _ = match[0], name = match[1], value = match[2];
        name = name.trim();
        value = value.trim();
        return Z[name] = value;
      };
    })(this))).pipe(D.$on_end(function() {
      return handler(null, Z);
    }));
    return null;
  };

  this.write_pdf = function(layout_info, handler) {
    var aux_locator, count, digest, last_digest, pdf_command, pdf_from_tex, tex_locator, tmp_home;
    pdf_command = njs_path.join(__dirname, 'pdf-from-tex.sh');
    tmp_home = __dirname;
    tex_locator = njs_path.join(__dirname, 'load-with-absolute-path.tex');
    aux_locator = njs_path.join(__dirname, 'load-with-absolute-path.aux');
    last_digest = null;
    if (njs_fs.existsSync(aux_locator)) {
      last_digest = CND.id_from_route(aux_locator);
    }
    digest = null;
    count = 0;
    pdf_from_tex = (function(_this) {
      return function(next) {
        count += 1;
        urge("run #" + count + " " + pdf_command);
        whisper("$1: " + tmp_home);
        whisper("$2: " + tex_locator);
        return CND.spawn(pdf_command, [tmp_home, tex_locator], function(error, data) {
          if (error === 0) {
            error = void 0;
          }
          if (error != null) {
            alert(error);
            return handler(error);
          }
          digest = CND.id_from_route(aux_locator);
          if (digest === last_digest) {
            echo(CND.grey(badge), CND.lime("done."));

            /* TAINT move pdf to layout_info[ 'source-home' ] */
            return handler(null);
          } else {
            last_digest = digest;
            return next();
          }
        });
      };
    })(this);
    return ASYNC.forever(pdf_from_tex);
  };

  this.test_versions = function() {
    var fn, i, len, name, package_names, tasks;
    tasks = [];
    package_names = "xcolor\nfontspec\nleading\npbox\npolyglossia\nbxjscls\npawpict\nbiblatex-juradiss\nlm\nametsoc\nbibleref-french\nxnewcommand\nsemantic\nmultiobjective\nshipunov\nsplitindex\nchkfloat\ncrbox\nsvgcolor\npstools\nsty2dtx\nreadarray\nlpic\nlhelp\nnewvbtm\nmathpazo\ndot2texi\nlcdftypetools\npst-fun\npst-tools\nmex\nflowchart\nhfoldsty\nlatex-git-log".split(/\s+/);
    fn = (function(_this) {
      return function(name) {
        return tasks.push(function(done) {
          return _this._read_texlive_package_version(name, function(error, version) {
            if (error != null) {
              throw error;
            }
            if (version != null) {
              urge(name, CND.cyan(version), CND.truth(SEMVER.valid(version)), CND.truth(SEMVER.satisfies(version, '>=2.4.0')));
            }
            return done();
          });
        });
      };
    })(this);
    for (i = 0, len = package_names.length; i < len; i++) {
      name = package_names[i];
      fn(name);
    }
    return ASYNC.parallelLimit(tasks, 10, function() {
      return help("ok");
    });
  };

  this.main = function() {
    var settings_tex, settings_tex_route;
    settings_tex_route = njs_path.join(__dirname, 'mkts-settings.tex');
    settings_tex = "\\def\\foobar{example for a TeX-def macro}\n\\newcommand{\\mktsPathsMktsHome}{/Volumes/Storage/io/jizura/tex-inputs}\n\\newcommand{\\mktsPathsFontsHome}{/Volumes/Storage/io/jizura-fonts/fonts}";
    njs_fs.writeFileSync(settings_tex_route, settings_tex);
    return this.write_pdf(null, (function(_this) {
      return function(error) {
        if (error != null) {
          throw error;
        }
        return help("ok");
      };
    })(this));
  };

  if (module.parent == null) {
    step((function(_this) {
      return function*(resume) {
        var version;
        version = (yield _this.read_texlive_package_version('fontspec', resume));
        (yield _this.write_font_declarations(resume));
        return _this.main();
      };
    })(this));
  }

}).call(this);
