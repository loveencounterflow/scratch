// Generated by CoffeeScript 1.9.1
(function() {
  var CND, after, alert, badge, debug, dynamic_buffer, echo, eventually, every, f, fix_remarkably, g, help, immediately, info, iterate_over_maps, log, njs_fs, njs_path, njs_util, rainbow, rpr, step, suspend, test_archiver, test_bloem, test_bloom_stream, test_bloom_stream2, test_chr, test_codepoints, test_hollerith_codec, test_keys, test_require_coffee, test_symbol_as_error, test_xregexp3, try_lazy_require, try_slicing_html, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_util = require('util');

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'scratch';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  rainbow = CND.rainbow.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  eventually = suspend.eventually;

  immediately = suspend.immediately;

  every = suspend.every;

  test_require_coffee = function() {
    var CS, route, rqr_route, source;
    CS = require('coffee-script');
    route = '/Volumes/Storage/io/SCRATCH/load-with-absolute-path/options.coffee';
    debug('©SOE29', rqr_route = require.resolve(route));
    source = njs_fs.readFileSync(rqr_route, {
      encoding: 'utf-8'
    });
    debug('©jEOZd', CS.compile(source, {
      bare: true
    }));
    return debug('©U4Zmb', CS["eval"](source, {
      bare: true
    }));
  };

  test_require_coffee();

  test_chr = function() {
    var CHR;
    CHR = require('coffeenode-chr');
    debug('©K6tf7', CHR.as_rsg('&cdp#x8deb;', {
      input: 'xncr'
    }));
    debug('©K6tf7', CHR.as_rsg('&#x21b7a;', {
      input: 'xncr'
    }));
    return debug('©K6tf7', CHR.as_rsg('鿉', {
      input: 'xncr'
    }));
  };

  f = function() {
    var a, demofs, handler, ref;
    a = arguments.slice(0, arguments.length - 1);
    if (((!global['Reflect']) != null) || (((ref = global['Proxy']) != null ? ref['create'] : void 0) != null)) {

      /* https://github.com/tvcutsem/harmony-reflect */
      global['Reflect'] = require('harmony-reflect');
    }
    handler = {
      get: function(target, key) {
        warn('>>>', key);
        return target[key];
      }
    };
    demofs = new Proxy(require('./demofs'), handler);
    return null;
  };

  fix_remarkably = function() {
    process.chdir('/Volumes/Storage/io/remarkably');
    return debug('©pPhY8', require('.'));
  };

  try_lazy_require = function() {
    var D, name;
    D = {};
    Object.defineProperty(D, 'FOO', {
      get: function() {
        urge('XXXXXXX');
        return require('pipedreams');
      }
    });
    D.FOO = D.FOO;
    return debug('©x7Tof', (function() {
      var results;
      results = [];
      for (name in D.FOO) {
        results.push(name);
      }
      return results;
    })());
  };

  try_slicing_html = function() {
    var HOTMETAL, blocks_hotml, document_hotml, document_html;
    HOTMETAL = require('../hotmetal');
    document_html = "<p>some words</p>\n<p>b</p>\n<p></p>";
    document_hotml = HOTMETAL.HTML.parse(document_html);
    blocks_hotml = HOTMETAL.slice_toplevel_tags(document_hotml);
    urge('©l9k4h', HOTMETAL.as_html(document_hotml));
    debug('©l9k4h', blocks_hotml);
    debug('©l9k4h', blocks_hotml.length);
    return debug('©l9k4h', HOTMETAL.as_html(blocks_hotml[1]));
  };

  dynamic_buffer = function() {
    var buffer, error;
    buffer = new Buffer(3);
    buffer.fill(0);
    buffer.writeUIntBE(0xa1, 0, 1);
    buffer.writeUIntBE(0xa2, 1, 1);
    buffer.writeUIntBE(0xa3, 2, 1);
    try {
      buffer.writeUIntBE(0xa4, 3, 1);
    } catch (_error) {
      error = _error;
      debug('©FpHyj', rpr(error.prototype));
      debug('©FpHyj', rpr(error['message']));
      debug('©FpHyj', rpr(error['code']));
      throw error;
    }
    return debug('©zZZo2', buffer);
  };

  test_symbol_as_error = function() {
    var error, s;
    s = Symbol('xxx');
    try {
      throw s;
    } catch (_error) {
      error = _error;
      help(error);
      return help(error === s);
    }
  };

  test_hollerith_codec = function() {
    var CODEC, long_text;
    CODEC = require('/Volumes/Storage/io/hollerith-codec');
    debug('©sjAHS', CODEC.encode(['helo']));
    long_text = (new Array(1025)).join('#');
    return debug('©sjAHS', CODEC.encode(['foo', [long_text, long_text, long_text, long_text], 42]));
  };

  test_codepoints = function() {
    var chr, j, len, ref, results;
    ref = 'äö𪜀';
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      chr = ref[j];
      results.push(help(chr));
    }
    return results;
  };

  test_bloem = function() {
    var $, BLOOM, D, PSON, bloom_data, buffer, data, initialDictionary, njs_zlib, old_bloom, pson, settings, zlib_settings;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    njs_zlib = require('zlib');
    PSON = require('pson');
    BLOOM = CND.BLOOM;
    settings = {
      size: 10
    };
    old_bloom = new BLOOM.new_filter(settings);
    BLOOM.add(old_bloom, new Buffer('helo world'));
    BLOOM.add(old_bloom, new Buffer('how are you'));
    BLOOM.report(old_bloom);
    help('©pOGr6', old_bloom);
    bloom_data = BLOOM.as_buffer(old_bloom);
    debug('©pOGr6', bloom_data.length);
    initialDictionary = ['foo'];
    pson = new PSON.ProgressivePair(initialDictionary);
    data = {
      "hello": "world!"
    };
    buffer = pson.toBuffer(JSON.stringify(old_bloom));
    debug('©Pmfq1', buffer);
    debug('©Pmfq1', buffer.length);
    urge('©RTDLw', pson.decode(buffer));
    zlib_settings = {
      level: njs_zlib.Z_NO_COMPRESSION
    };
    debug('©KdT6C', njs_zlib.deflateSync('helo'));
    debug('©KdT6C', njs_zlib.deflateSync('dddddddddddddddddddddddd'));
    debug('©KdT6C', (njs_zlib.deflateSync(bloom_data)).length);
    return debug('©KdT6C', (njs_zlib.deflateSync(bloom_data, zlib_settings)).length);
  };

  test_archiver = function() {
    var archive, archiver;
    archiver = require('archiver');
    archive = archiver.create('zip', {});
    archive.pipe($((function(_this) {
      return function(data, send) {
        whisper(rpr(data));
        return send(data);
      };
    })(this)));
    archive.on('end', (function(_this) {
      return function() {
        return help(archive.pointer());
      };
    })(this));
    archive.on('error', (function(_this) {
      return function(error) {
        throw error;
      };
    })(this));
    archive.append('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', {
      name: 'my-text'
    });
    return archive.finalize();
  };

  test_keys = function() {
    var db;
    this.create_facetstream = function(db, settings) {
      var arity, hi_hint, key, keys, lo_hint;
      lo_hint = null;
      hi_hint = null;
      if (settings != null) {
        keys = Object.keys(settings);
        switch (arity = keys.length) {
          case 1:
            switch (key = keys[0]) {
              case 'lo':
              case 'prefix':
                lo_hint = settings[key];
                break;
              case 'hi':
                hi_hint = settings[key];
                break;
              default:
                if (key !== 'prefix' && key !== 'lo' && key !== 'hi') {
                  throw new Error("unknown hint key " + (rpr(key)));
                }
            }
            break;
          case 2:
            keys.sort();
            if (keys[0] === 'hi' && keys[1] === 'lo') {
              lo_hint = settings['lo'];
              hi_hint = settings['hi'];
            } else if (keys[0] === 'prefix' && keys[1] === 'star') {
              lo_hint = settings['prefix'];
              hi_hint = settings['star'];
            } else {
              throw new Error("illegal hint keys " + (rpr(keys)));
            }
            break;
          default:
            throw new Error("illegal hint arity " + (rpr(arity)));
        }
      }
      return debug('©KaWp7', lo_hint, hi_hint);
    };
    db = null;
    this.create_facetstream(db);
    this.create_facetstream(db, {
      lo: ['bar']
    });
    this.create_facetstream(db, {
      hi: ['foo']
    });
    this.create_facetstream(db, {
      lo: ['bar'],
      hi: ['foo']
    });
    this.create_facetstream(db, {
      prefix: ['foo']
    });
    return this.create_facetstream(db, {
      prefix: ['foo'],
      star: '*'
    });
  };

  test_bloom_stream2 = function() {
    var $, Bloom, D, HOLLERITH, bloom, encode, idx, input, j, key, seen, ƒ;
    ƒ = CND.format_number;
    HOLLERITH = require('/Volumes/Storage/io/hollerith2');
    Bloom = require('bloom-stream');
    D = require('pipedreams');
    encode = function(data) {
      return new Buffer(JSON.stringify(data));
    };
    $ = D.remit.bind(D);

    /* Bloom.forCapacity(capacity, errorRate, seed, hashType, streamOpts) */
    bloom = Bloom.forCapacity(1e6, 0.01);
    seen = {};
    input = D.create_throughstream();
    input.pipe($(function(data, send) {
      seen[data] = 1;
      debug('©rAv0J', data);
      return send(data);
    })).pipe($(function(data, send) {
      return send(encode(data));
    })).pipe(bloom);
    bloom.on('finish', function*() {
      var color, d, idx, j, l, len, register, register_idx, registers, registers_bfr, s, t0, t1;
      for (idx = j = 0; j <= 20; idx = ++j) {
        d = bloom.has(encode(idx));
        color = d ? CND.green : CND.red;
        log(color(idx, d));
      }
      help("filter size: " + (ƒ((new Buffer(JSON.stringify(bloom["export"]()))).length)) + " bytes");
      registers = bloom["export"]()['registers'];
      for (register_idx = l = 0, len = registers.length; l < len; register_idx = ++l) {
        register = registers[register_idx];
        if (register == null) {
          registers[register_idx] = null;
        }
      }
      registers_bfr = HOLLERITH._encode_key(null, registers);
      help("filter size: " + (ƒ(registers_bfr.length)) + " bytes");
      help("1:1 storage size: " + (ƒ((new Buffer(JSON.stringify((function() {
        var results;
        results = [];
        for (s in seen) {
          results.push(s);
        }
        return results;
      })()))).length)) + " bytes");
      t0 = new Date();
      (yield leveldb.put('x', 'y'));
      t1 = new Date();
      debug('©8yyXq', t1 - t0);
    });
    for (idx = j = 0; j <= 10; idx = j += 3) {
      key = "abcdefghijklmnop/" + idx;
      input.write(key);
      debug('©0QQhI', 'd');
    }
    return input.end();
  };

  test_bloom_stream = function() {
    var $, Bloom, D, bloom, encode, idx, input, j;
    Bloom = require('bloom-stream');
    D = require('pipedreams');
    encode = function(data) {
      return new Buffer(JSON.stringify(data));
    };
    $ = D.remit.bind(D);

    /* Bloom.forCapacity(capacity, errorRate, seed, hashType, streamOpts) */
    bloom = Bloom.forCapacity(1e1, 1);
    input = D.create_throughstream();
    input.pipe($(function(data, send) {
      return send(encode(data));
    })).pipe(bloom);
    bloom.on('finish', function() {
      var color, d, idx, j;
      for (idx = j = 0; j <= 20; idx = ++j) {
        d = bloom.has(encode(idx));
        color = d ? CND.green : CND.red;
        log(color(idx, d));
      }
      debug('©fpWF8', bloom["export"]());
    });
    for (idx = j = 0; j <= 10; idx = j += 3) {
      input.write(idx);
    }
    return input.end();
  };

  g = function() {
    var test_todolist_tsort, test_tsort, test_yargs;
    test_yargs = function() {
      var argv;
      argv = require('yargs').usage('Usage: $0 <command> [options]').command("count", 'Count the lines in a file').command("foo", 'Foo the lines in a file').demand(1).example('$0 count -f foo.js', 'count the lines in the given file').demand('f').alias('f', 'file').nargs('f', 1).describe('f', 'Load a file').help('h').alias('h', 'help').epilog('copyright 2015').argv;
      return debug('©vRlET', argv);
    };
    test_yargs();
    test_todolist_tsort = function() {
      var TS, settings;
      TS = CND.TSORT;
      settings = {
        strict: true
      };
      g = TS.new_graph(settings);
      help((TS.link_down(g, 'buy food', 'cook')).join(' > '));
      help((TS.link_down(g, 'fetch money', 'buy food')).join(' > '));
      help((TS.link_down(g, 'do some reading', 'go to exam')).join(' > '));
      help((TS.link_down(g, 'cook', 'eat')).join(' > '));
      help((TS.link_down(g, 'go to bank', 'fetch money')).join(' > '));
      help((TS.link_down(g, 'fetch money', 'buy books')).join(' > '));
      help((TS.link_down(g, 'buy books', 'do some reading')).join(' > '));
      help((TS.link_down(g, 'go to market', 'buy food')).join(' > '));
      help();
      help((TS.link_down(g, 'buy food', 'go home')).join(' > '));
      help((TS.link_down(g, 'buy books', 'go home')).join(' > '));
      help((TS.link_down(g, 'go home', 'cook')).join(' > '));
      return help((TS.link_down(g, 'eat', 'go to exam')).join(' > '));
    };
    return test_tsort = function() {
      var TS, graph, matcher, nodes, settings;
      TS = CND.TSORT;
      settings = {
        strict: true,
        prefixes: ['f|', 'g|']
      };
      graph = TS.new_graph(settings);
      urge('1', TS.link(graph, 'id', '-', 'id'));
      urge('2', TS.link(graph, 'id', '>', '+'));
      urge('3', TS.link(graph, 'id', '>', '*'));
      urge('4', TS.link(graph, 'id', '>', '$'));
      urge('5', TS.link(graph, '+', '<', 'id'));
      urge('6', TS.link(graph, '+', '>', '+'));
      urge('7', TS.link(graph, '+', '<', '*'));
      urge('8', TS.link(graph, '+', '>', '$'));
      urge('9', TS.link(graph, '*', '<', 'id'));
      urge('10', TS.link(graph, '*', '>', '+'));
      urge('11', TS.link(graph, '*', '>', '*'));
      urge('12', TS.link(graph, '*', '>', '$'));
      urge('13', TS.link(graph, '$', '<', 'id'));
      urge('14', TS.link(graph, '$', '<', '+'));
      urge('15', TS.link(graph, '$', '<', '*'));
      urge('16', TS.link(graph, '$', '-', '$'));
      debug('©DE1h1', graph);
      help(nodes = TS.sort(graph));
      matcher = ['f|id', 'g|id', 'f|*', 'g|*', 'f|+', 'g|+', 'g|$', 'f|$'];
      if (!CND.equals(nodes, matcher)) {
        throw new Error("is: " + (rpr(nodes)) + "\nexpected:  " + (rpr(matcher)));
      }
      help(TS.get_precedences(graph));
      help(TS.precedence_of(graph, 'f|id'));
      help(TS.precedence_of(graph, 'f|$'));
      urge('1', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|+')));
      urge('2', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|*')));
      urge('3', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|$')));
      urge('4', (TS.precedence_of(graph, 'f|+')) < (TS.precedence_of(graph, 'g|id')));
      urge('5', (TS.precedence_of(graph, 'f|+')) > (TS.precedence_of(graph, 'g|+')));
      urge('6', (TS.precedence_of(graph, 'f|+')) < (TS.precedence_of(graph, 'g|*')));
      urge('7', (TS.precedence_of(graph, 'f|+')) > (TS.precedence_of(graph, 'g|$')));
      urge('8', (TS.precedence_of(graph, 'f|*')) < (TS.precedence_of(graph, 'g|id')));
      urge('9', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|+')));
      urge('10', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|*')));
      urge('11', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|$')));
      urge('12', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|id')));
      urge('13', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|+')));
      return urge('14', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|*')));
    };
  };


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  iterate_over_maps = function() {
    var d, k, list_from_iterator;
    list_from_iterator = function(iterator) {
      var R;
      R = [];
      for ( x of iterator ){ R.push( x ); };
      return R;
    };
    d = new Map();
    k = [1, 2];
    d.set(k, 42);
    d.set([1, 2], 33);
    debug('©ZUwOO', d.get(k));
    debug('©ZUwOO', d.get([1, 2]));
    CND.dir(d);
    debug('©g60BV', d.size);
    debug('©Vdchi', d.entries());
    debug('©Vdchi', d.entries().length);
    debug('©Vdchi', list_from_iterator(d.keys()));
    debug('©Vdchi', list_from_iterator(d.entries()));
    debug('©Vdchi', list_from_iterator(d.values()));
    debug('©KzfCH', d.keys());
    debug('©GreeH', typeof d.values());
    debug('©GreeH', CND.type_of(d.values()));
    debug('©GreeH', Object.prototype.toString.call(d.values()));
    return debug('©GreeH', Symbol.iterator);
  };

  test_xregexp3 = function() {

    /* See:
      https://github.com/loveencounterflow/xregexp3
      https://github.com/slevithan/xregexp/wiki/Roadmap
      https://gist.github.com/slevithan/2630353
      http://blog.stevenlevithan.com/archives/javascript-regex-and-unicode
     */
    var XRegExp, base_tokens_of, d, insert, match, matches, new_parse, parse, position, recognize_assignments, recognize_eos_mark, show, text, token_pattern, token_patterns, tokens, topmost_of;
    XRegExp = require('xregexp3');

    /* Always allow expressions like `\p{...}` to match beyond the Unicode BMP: */

    /* Always allow new extensions: */
    XRegExp.install('extensibility');
    token_patterns = [XRegExp("('{3}|\"{3}|\\p{L}+|\\p{Z}+|\\p{N}+|\\p{P}|\\p{S}|.+)")];
    insert = function(me, value, position, probe) {
      var R, arity;
      if (position == null) {
        position = 'last';
      }
      arity = arguments.length;
      switch (position) {
        case 'first':
          me.splice(0, 0, value);
          R = 0;
          break;
        case 'last':
          me.push(value);
          R = me.length - 1;
          break;
        case 'before':
        case 'after':
          if (arity !== 4) {
            throw new Error("expected 4 arguments, got " + arity);
          }
          R = me.indexOf(probe);
          if (!(R >= 0)) {
            throw new Error("unable to find " + (rpr(value)) + " in list");
          }
          me.splice(R, 0, value);
      }
      return R;
    };
    d = [];
    debug('©U08qy', insert(d, '+'));
    debug('©Gz6lh', insert(d, '*'));
    debug('©I23qn', insert(d, '-', 'before', '*'));
    debug('©U08qy', insert(d, '~'));
    debug('©BlRvr', d);
    topmost_of = function(stack) {
      return stack[stack.length - 1];
    };
    base_tokens_of = function(text) {
      var j, len, ref, results, t;
      ref = text.split(topmost_of(token_patterns));
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        if (t !== '') {
          results.push(t);
        }
      }
      return results;
    };
    show = function(tokens) {
      var colors, i, t;
      colors = [CND.lime, CND.orange];
      log(((function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = tokens.length; j < len; i = ++j) {
          t = tokens[i];
          results.push(colors[i % 2](t.replace(/\s/g, '␣')));
        }
        return results;
      })()).join(' '));
      return null;
    };
    recognize_assignments = function(tokens) {
      var R, j, len, skip, token, token_idx;
      R = [];
      skip = 0;
      for (token_idx = j = 0, len = tokens.length; j < len; token_idx = ++j) {
        token = tokens[token_idx];
        if (skip > 0) {
          skip += -1;
          continue;
        }
        if (token.length > 1 && /:$/.test(token)) {
          R.push(token.slice(0, +(token.length - 2) + 1 || 9e9));
          R.push(token[token.length - 1]);
          continue;
        }
        R.push(token);
      }
      return R;
    };
    recognize_eos_mark = function(tokens) {
      var R, j, len, skip, token, token_idx;
      R = [];
      skip = 0;
      for (token_idx = j = 0, len = tokens.length; j < len; token_idx = ++j) {
        token = tokens[token_idx];
        if (skip > 0) {
          skip += -1;
          continue;
        }
        if (token.length > 1 && /;$/.test(token)) {
          R.push(token.slice(0, +(token.length - 2) + 1 || 9e9));
          R.push(token[token.length - 1]);
          continue;
        }
        R.push(token);
      }
      return R;
    };
    text = "helo 345world(d) '''34 great''' (,sw x";
    text = "d: foo/bar/$baz + /k += 3";
    text = "3+1*2*4+5";
    text = "foo: 34e3 + 1 ** +bar; baz: 42";
    tokens = base_tokens_of(text);
    show(tokens);
    tokens = recognize_assignments(tokens);
    show(tokens);
    tokens = recognize_eos_mark(tokens);
    show(tokens);
    position = 0;
    matches = [];
    match = null;
    token_pattern = topmost_of(token_patterns);
    while (match = XRegExp.exec(text, token_pattern, position, 'sticky')) {
      matches.push(match[1]);
      position = match.index + match[0].length;
    }
    show(matches);
    new_parse = require('tdop');
    parse = new_parse();
    help(parse('var a = 1 + 1;'));
    return urge(parse("var f = function(){};\nvar x = f(8);"));
  };

  f = function() {
    var isolate_content, match_newlines, parse_md, show_inherited_names, symbols_as_attributes, test_cs_lexer, test_error, test_gm, test_hummus, test_pdfinfo, test_regex_safeness, write_numbers;
    test_cs_lexer = function() {
      var Lexer, lexer, settings, source;
      Lexer = require('coffee-script/lib/coffee-script/lexer').Lexer;
      lexer = new Lexer();
      source = "f 'helo'";
      settings = {
        sourceMap: false
      };
      return debug('©2LYns', lexer.tokenize(source, settings));
    };
    test_cs_lexer();
    test_error = function() {
      var add_symbol, error, j, len, name, new_error, ref, x0, x1, y0, y1;
      require('es6-symbol/implement');
      x0 = Symbol('x');
      x1 = Symbol('x');
      y0 = Symbol["for"]('y');
      y1 = Symbol["for"]('y');
      debug('©s7yDl', x0 === x1);
      debug('©s7yDl', y0 === y1);
      this.codes = {};
      add_symbol = function(host, name) {
        var R;
        if ((R = host[name]) != null) {
          return R;
        }
        R = Symbol(name);
        host[name] = R;
        host[R] = name;
        return R;
      };
      new_error = function(host, code, message) {
        var R;
        R = new Error(message);
        code = add_symbol(host, code);
        R['code'] = code;
        return R;
      };
      ref = ['not implemented', 'division by zero'];
      for (j = 0, len = ref.length; j < len; j++) {
        name = ref[j];
        add_symbol(this, name);
      }
      error = this.new_error(this.codes, 'unknown name', "unknown name: 'xy'");
      debug('©c9Pf5', this.codes);
      debug('©c9Pf5', error);
      debug('©EDcXf', error['code']);
      debug('©EDcXf', error['code'] === this['codes']['unknown name']);
      throw error;
    };
    test_error();
    test_hummus = function() {
      var hummus;
      hummus = require('hummus');
      return 
    var pdfWriter = hummus.createWriterToModify(
                                         '/tmp/kwic-all-excerpts.pdf',
                                         {modifiedFilePath:'/tmp/kwic-all-excerpts-mod.pdf'});
    var pageModifier = new hummus.PDFPageModifier(pdfWriter,0);
    var cxt = pageModifier.startContext().getContext();
    cxt.drawCircle(
                  centerX,
                  centerY,
                  radius,
                  {
                      type:stroke,
                      width:1,
                      color:'black'
                  });
    pageModifier.endContext().writePage();
    pdfWriter.end();
    ;
    };
    test_hummus();
    show_inherited_names = function() {

      /* http://stackoverflow.com/a/8024294/256361 */
      var get_all_property_names;
      get_all_property_names = function(x) {
        var R, j, len, name, ref;
        R = [];
        while (true) {
          if (indexOf.call(R, name) < 0) {
            ref = Object.getOwnPropertyNames(x);
            for (j = 0, len = ref.length; j < len; j++) {
              name = ref[j];
              R.push(name);
            }
          }
          if ((x = Object.getPrototypeOf(x)) == null) {
            break;
          }
        }
        return R;
      };
      debug('©A3bXj', get_all_property_names([]));
      debug('©A3bXj', get_all_property_names([1, 2, 3]));
      debug('©qAxof', get_all_property_names({}));
      debug('©smLj8', get_all_property_names({
        'foo': 'bar'
      }));
      debug('©smLj8', {
        'foo': 'bar'
      }['constructor']);
      debug('©smLj8', (Object.getPrototypeOf({
        'foo': 'bar'
      })) != null);
      debug('©smLj8', Object.getOwnPropertyNames(Object.getPrototypeOf({
        'foo': 'bar'
      })));
      debug('©034vW', get_all_property_names(Object.create(null)));
      return CND.dir({});
    };
    show_inherited_names();
    test_gm = function() {
      var new_pdf, pdf, pdf_route;
      new_pdf = require('gm');
      pdf_route = '/Volumes/Storage/io/jizura-datasources/data/4-pdf/kwic-all.pdf';
      pdf = new_pdf(pdf_route);
      return pdf.identify(pdf_route, function(error, data) {
        if (error != null) {
          throw error;
        }
        return debug('©oP284', data);
      });
    };
    test_gm();
    test_pdfinfo = function() {
      var command, njs_cp, pattern, pdf_route;
      njs_cp = require('child_process');
      pdf_route = '/Volumes/Storage/io/jizura-datasources/data/4-pdf/kwic-all.pdf';
      command = "pdfinfo -meta " + pdf_route;
      pattern = /\nPages:\s+([0-9]+)\n/;
      return njs_cp.exec(command, function(error, stdout, stderr) {
        var match, page_count;
        if (error != null) {
          throw error;
        }
        warn(stderr);
        help(stdout);
        if ((match = stdout.match(pattern)) == null) {
          throw new Error("unable to read pdfinfo output " + (rpr(stdout)));
        }
        debug('©KJayE', rpr(match[1]));
        page_count = parseInt(match[1], 10);
        return debug('©1Dkzn', rpr(page_count));
      });
    };
    test_pdfinfo();
    test_regex_safeness = function() {

      /* https://github.com/substack/safe-regex */
      var matcher, probe, regex_is_safe;
      regex_is_safe = require('safe-regex');
      matcher = /^\n?‡(\S+?)\n$/;
      debug('©Md6b4', regex_is_safe(/(a+){10}/));
      debug('©Jdjoh', regex_is_safe(/^(\S+)\s+(.+)$/));
      debug('©6UvDi', regex_is_safe(matcher));
      probe = '\n‡abc\n';
      return debug('©32VzH', probe.match(matcher));
    };
    test_regex_safeness();
    process.exit();
    match_newlines = function() {
      var matcher, probe;
      matcher = /^\n?‡(\S+?)\n$/;
      probe = '\n‡abc\n';
      return debug('©32VzH', probe.match(matcher));
    };
    match_newlines();
    process.exit();
    isolate_content = function() {
      var matcher, register_intro_route, register_intro_tex;
      register_intro_route = '/Volumes/Storage/io/jizura-datasources/data/3-tex-generated/kwic-register-intro.tex';
      register_intro_tex = njs_fs.readFileSync(register_intro_route, 'utf-8');
      matcher = /^[\s\S]*\\begin\{document\}([\s\S]+)\\end\{document\}[\s\S]*$/;
      register_intro_tex = register_intro_tex.replace(matcher, '$1');
      return debug('©dJ32E', register_intro_tex);
    };
    isolate_content();
    process.exit();
    symbols_as_attributes = function() {
      var d, name, s, value;
      d = {
        foo: 42
      };
      s = Symbol('magic');
      debug('©RedP2', (Symbol('magic')) === (Symbol('magic')));
      debug('©RedP2', (Symbol["for"]('magic')) === (Symbol["for"]('magic')));
      d[s] = "it's magic";
      debug('©VbITC', rpr(d));
      debug('©VbITC', rpr(s));
      debug('©LFg8G', Object.keys(d));
      return debug('©LFg8G', (function() {
        var results;
        results = [];
        for (name in d) {
          value = d[name];
          results.push([name, value]);
        }
        return results;
      })());
    };
    symbols_as_attributes();
    process.exit();
    write_numbers = function() {
      var cid, cids, j, len, number, results;
      cids = [0x0020, 0x00A0, 0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x200B, 0x202F, 0x205F, 0x3000, 0xFEFF];
      number = "100'000'000'000'000'000'000'000'000'000'000'000'000'000'000'000'000";
      echo(number.replace(/'/g, ''));
      results = [];
      for (j = 0, len = cids.length; j < len; j++) {
        cid = cids[j];
        results.push(echo(number.replace(/'/g, String.fromCharCode(cid)), "0x" + (cid.toString(16))));
      }
      return results;
    };
    write_numbers();
    process.exit();
    parse_md = function() {
      var R, md, settings, source_references;
      settings = {
        html: true,
        linkify: false,
        breaks: false,
        langPrefix: 'codelang-',
        typographer: true,
        quotes: '“”‘’',
        source_references: true
      };
      source_references = require('coffeenode-markdown-it/lib/rules_core/source_references');
      R = (require('coffeenode-markdown-it'))(settings);
      R = R.use(source_references, {
        template: "<rf loc='${start},${stop}'></rf>"
      });
      md = "# hello\n\n<!--#123-->\n\nworld\n\nyet *another* paragraph\n\n```\nsome code\n```\n";

      /*
      { type: 'inline',
          content: 'world<!-- 123 -->',
          level: 1,
          lines: [ 2, 3 ],
          children:
           [ { type: 'text', content: 'world', level: 0 },
             { type: 'html_inline', content: '<!-- 123 -->', level: 0 } ] },
       */
      return help(R.render(md));
    };
    parse_md();
    return process.exit();
  };

}).call(this);
