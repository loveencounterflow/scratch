// Generated by CoffeeScript 1.9.3
(function() {
  var CND, HOLLERITH_select, MKTS_copy, PIPEDREAMS_collect, after, alert, badge, caller_identity, content_addressable_storage, debug, dynamic_buffer, echo, eventually, every, exec_and_eval_coffeescript, f, find_duplicated_guides, fix_remarkably, g, help, immediately, info, iterate_over_maps, log, nice_text_rpr, njs_fs, njs_path, njs_util, pipedreams_duplex, pipedreams_with_fittings, rainbow, rpr, step, suspend, test_MKTS_raw_escaper, test_archiver, test_bloem, test_bloom_stream, test_bloom_stream2, test_chr, test_codepoints, test_hollerith_codec, test_keys, test_markdown_it_footnotes, test_permutations, test_require_coffee, test_symbol_as_error, test_xregexp3, try_lazy_require, try_slicing_html, urge, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_util = require('util');

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'scratch';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  rainbow = CND.rainbow.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  eventually = suspend.eventually;

  immediately = suspend.immediately;

  every = suspend.every;

  HOLLERITH_select = function() {
    var $, $async, ASYNC, D, HOLLERITH, create_livestream, create_resultstream, search;
    ASYNC = require('async');
    HOLLERITH = require('../hollerith');
    D = require('../pipedreams');
    $ = D.remit.bind(D);
    $async = D.remit_async.bind(D);

    /* https://github.com/dominictarr/level-live-stream */

    /* Alternative: https://github.com/Raynos/level-livefeed */
    create_livestream = require('level-live-stream');
    HOLLERITH.$decode = function(db) {

      /* TAINT should not require `db` as argument */
      return $((function(_this) {
        return function(batch_entry, send) {
          var key, value;
          key = batch_entry.key, value = batch_entry.value;
          if (!_this._is_meta(db, key)) {
            batch_entry['key'] = _this._decode_key(db, key);
            if (value !== void 0) {
              batch_entry['value'] = _this._decode_value(db, value);
            }
            return send(batch_entry);
          }
        };
      })(this));
    };
    HOLLERITH.$count = function(part_of_speech) {
      var counts;
      if (part_of_speech !== 's' && part_of_speech !== 'p' && part_of_speech !== 'o') {
        throw new Error("expected one of 's', 'p', 'o', got " + (rpr(part_of_speech)));
      }
      counts = {};
      return $((function(_this) {
        return function(phrase, send, end) {
          var _, count, idx, obj, prd, ref, sbj, value;
          if (phrase != null) {
            if (phrase[0] !== 'pos') {
              throw new Error("xxx");
            }
            _ = phrase[0], prd = phrase[1], obj = phrase[2], sbj = phrase[3], idx = phrase[4];
            value = (function() {
              switch (part_of_speech) {
                case 's':
                  return sbj;
                case 'p':
                  return prd;
                case 'o':
                  return obj;
              }
            })();

            /* TAINT should properly check for inner/outer codepoint */
            if (!sbj.startsWith('&')) {
              counts[value] = ((ref = counts[value]) != null ? ref : 0) + 1;
            }
          }
          if (end != null) {
            for (value in counts) {
              count = counts[value];
              send([value, count]);
            }
            return end();
          }
        };
      })(this));
    };
    HOLLERITH.prune = function(me, prefix, filter, handler) {
      var db_substrate, input, query;
      db_substrate = me['%self'];
      query = {
        prefix: prefix,
        star: '*'
      };
      input = this.create_phrasestream(me, query);
      input.pipe($async((function(_this) {
        return function(phrase, done) {
          var key, key_bfr;
          if (!filter(phrase)) {
            key = phrase.slice(0, 3);
            key_bfr = _this._encode_key(db_substrate, key);
            return db_substrate.del(key_bfr, function(error) {
              if (error != null) {
                throw error;
              }
              return done();
            });
          } else {
            return done(phrase);
          }
        };
      })(this))).pipe(D.$show()).pipe(D.$on_end((function(_this) {
        return function() {
          return handler(null);
        };
      })(this)));
      return null;
    };
    create_resultstream = function(db) {
      var R, db_substrate, query, settings;
      db_substrate = db['%self'];
      query = HOLLERITH._query_from_prefix(db, ['spo']);

      /* see https://github.com/dominictarr/level-live-stream/#options */
      settings = {
        tail: true,
        old: false,
        min: query['gte'],
        max: query['lte']
      };
      R = create_livestream(db_substrate, settings);
      R = R.pipe(HOLLERITH.$decode(db)).pipe($((function(_this) {
        return function(facet, send) {
          var _, ref, sbj;
          (ref = facet[0], _ = ref[0], sbj = ref[1], _ = ref[2]), _ = facet[1];
          return send(sbj);
        };
      })(this)));
      return R;
    };
    search = function(source_db, target_db, prefix, handler) {

      /* TAINT use of star not correct */
      var accumulator, input, query;
      query = {
        prefix: prefix,
        star: '*'
      };
      input = HOLLERITH.create_phrasestream(source_db, query);
      accumulator = D.create_throughstream();
      accumulator.pipe($async((function(_this) {
        return function(arg, done) {
          var obj, prd, sbj, sub_prefix, sub_query;
          sbj = arg[0], prd = arg[1], obj = arg[2];
          sub_prefix = ['spo', sbj, prd];
          sub_query = {
            prefix: sub_prefix,
            fallback: null
          };
          return HOLLERITH.read_one_phrase(target_db, sub_query, function(error, result) {
            if (error != null) {
              return done.error(error);
            }
            if (result != null) {
              result.splice(0, 1);
              result[2] += +1;
              return done(result);
            } else {
              return done([sbj, prd, obj + 1]);
            }
          });
        };
      })(this))).pipe(HOLLERITH.$write(target_db, {
        unique: false,
        solids: ['count'],
        loners: ['count']
      })).pipe(D.$on_end((function(_this) {
        return function() {
          return handler(null);
        };
      })(this)));
      return input.pipe($((function(_this) {
        return function(phrase, send) {
          var _, idx, obj, prd, sbj;
          _ = phrase[0], prd = phrase[1], obj = phrase[2], sbj = phrase[3], idx = phrase[4];
          if (sbj.startsWith('&')) {
            return;
          }

          /* TAINT count must go to value */
          return send([sbj, 'count', 0]);
        };
      })(this))).pipe(accumulator);
    };
    return step((function(_this) {
      return function*(resume) {
        var confluence, ds_options, home, source_db, source_route, target_db, target_db_size, target_route, tasks;
        home = njs_path.resolve(__dirname, '../jizura-datasources');
        source_route = njs_path.resolve(home, 'data/leveldb-v2');
        target_route = njs_path.resolve(home, '/tmp/results');
        target_db_size = 1e6;
        ds_options = require(njs_path.resolve(home, 'options'));
        source_db = HOLLERITH.new_db(source_route);
        target_db = HOLLERITH.new_db(target_route, {
          size: target_db_size,
          create: true
        });
        (yield HOLLERITH.clear(target_db, resume));
        tasks = [];
        tasks.push(function(done) {
          return search(source_db, target_db, ['pos', 'guide/has/uchr', '氵'], done);
        });
        tasks.push(function(done) {
          return search(source_db, target_db, ['pos', 'guide/has/uchr', '太'], done);
        });
        ASYNC.parallel(tasks, function(error) {
          var filter;
          filter = function(phrase) {
            var count, phrasetype, prd, sbj;
            phrasetype = phrase[0], sbj = phrase[1], prd = phrase[2], count = phrase[3];
            if (!((phrasetype === 'spo') && (prd === 'count') && (CND.isa_number(count)))) {
              throw new Error("expected SPO phrase with predicate 'count', got " + (rpr(phrase)));
            }
            return count >= tasks.length;
          };
          return HOLLERITH.prune(target_db, ['spo'], filter, function(error) {
            return debug('©ΖΛΜΤΞ');
          });
        });
        confluence = create_resultstream(target_db);
        return null;
      };
    })(this));
  };

  HOLLERITH_select();

  PIPEDREAMS_collect = function() {
    var $, $async, D, input, text;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    $async = D.remit_async.bind(D);
    text = "Just in order to stress it, a 'character’ in this chart is equivalent to 'a Unicode\ncodepoint’, so for example 馬 and 马 count as two characters, and 關, 关, 関, 闗, 𨶹 count\nas five characters. Dictionaries will list 馬马 as 'one character with two variants’\nand 關关関闗𨶹 as 'one character with five variants’, but that’s not what we’re counting\nhere.";
    input = D.stream_from_text(text);
    input.pipe(D.$show());
    input.resume();
    input = D.stream_from_text(text);
    input.pipe(D.$split()).pipe(D.$join('--\n')).pipe(D.$observe(function(data) {
      return urge(data);
    }));
    return input.resume();
  };

  nice_text_rpr = function() {
    var R, probe, text;
    text = "foo \u0010\u0012\u0015\nbar\"\"\"";
    debug('©ehFoE', rpr(text));
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = '"""' + R + '"""';
    probe = "foo \x10\x12\x15\nbar\"\"\"";
    debug('©0sWgm', text === probe);
    return echo(CND.white(R));
  };

  content_addressable_storage = function() {
    var CAS, d, misfit, store;
    misfit = Symbol('misfit');
    CAS = {};
    CAS.new_store = function() {
      var R;
      R = {
        '~isa': 'CAS/store',
        'id-by-content': new Map(),
        'index': []
      };
      return R;
    };
    CAS.set = function(me, content) {
      var R;
      if ((R = me['id-by-content'].get(content)) != null) {
        return R;
      }
      R = me['index'].length;
      me['id-by-content'].set(content, R);
      me['index'].push(content);
      return R;
    };
    CAS.get = function(me, id, fallback) {
      var R;
      if (fallback == null) {
        fallback = misfit;
      }
      if ((R = me['index'][id]) != null) {
        return R;
      }
      if (fallback !== misfit) {
        return fallback;
      }
      throw new Error("unknown ID " + (rpr(id)));
    };
    debug('©HpxVZ', store = CAS.new_store());
    debug('©FU7LE (1)', CAS.set(store, 42));
    debug('©FU7LE (2)', CAS.set(store, 'more'));
    debug('©FU7LE (3)', CAS.set(store, 'more of this'));
    debug('©FU7LE (4)', CAS.set(store, 'more of this'));
    debug('©FU7LE (5)', CAS.set(store, [32]));
    debug('©FU7LE (6)', CAS.set(store, [32]));
    debug('©FU7LE (7)', CAS.set(store, d = [32]));
    debug('©FU7LE (8)', CAS.set(store, d));
    debug('©FU7LE (9)', CAS.set(store, 'new'));
    debug('©n9l1r (10)', store);
    debug('©ZsxDc (11)', CAS.get(store, 1));
    debug('©ZsxDc (14)', CAS.get(store, 10, 'XXX'));
    return debug('©ZsxDc (15)', CAS.get(store, 10));
  };

  pipedreams_duplex = function() {
    var $, $async, D;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    $async = D.remit_async.bind(D);
    return (function() {
      var create_frob_fitting, fitting, input, inputs, l, n, output, outputs, results;
      create_frob_fitting = function(settings) {
        var add, inputs, multiply, outputs, square, transforms, unsquared;
        multiply = $((function(_this) {
          return function(data, send) {
            return send(data * 2);
          };
        })(this));
        add = $((function(_this) {
          return function(data, send) {
            return send(data + 2);
          };
        })(this));
        square = $((function(_this) {
          return function(data, send) {
            return send(Math.pow(data, 2));
          };
        })(this));
        unsquared = D.create_throughstream();
        inputs = {
          add: add
        };
        outputs = {
          unsquared: unsquared
        };
        transforms = [multiply, add, unsquared, square];
        return D.create_fitting(transforms, {
          inputs: inputs,
          outputs: outputs
        });
      };
      fitting = create_frob_fitting();
      input = fitting.input, output = fitting.output, inputs = fitting.inputs, outputs = fitting.outputs;
      outputs['unsquared'].pipe($(function(data, send) {
        return help('@unsquared:', data);
      }));
      output.pipe($(function(data, send) {
        if (data === 100) {
          inputs['add'].write(-10);
        }
        return send(data);
      })).pipe(D.$show());
      results = [];
      for (n = l = 1; l < 10; n = ++l) {
        results.push(input.write(n));
      }
      return results;
    })();
  };

  pipedreams_with_fittings = function() {
    var $, $async, D;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    $async = D.remit_async.bind(D);
    return (function() {
      var create_frob_fitting, fitting, input, inputs, l, n, output, outputs, results;
      create_frob_fitting = function(settings) {
        var add, inputs, multiply, outputs, square, transforms, unsquared;
        multiply = $((function(_this) {
          return function(data, send) {
            return send(data * 2);
          };
        })(this));
        add = $((function(_this) {
          return function(data, send) {
            return send(data + 2);
          };
        })(this));
        square = $((function(_this) {
          return function(data, send) {
            return send(Math.pow(data, 2));
          };
        })(this));
        unsquared = D.create_throughstream();
        inputs = {
          add: add
        };
        outputs = {
          unsquared: unsquared
        };
        transforms = [multiply, add, unsquared, square];
        return D.create_fitting(transforms, {
          inputs: inputs,
          outputs: outputs
        });
      };
      fitting = create_frob_fitting();
      input = fitting.input, output = fitting.output, inputs = fitting.inputs, outputs = fitting.outputs;
      outputs['unsquared'].pipe($(function(data, send) {
        return help('@unsquared:', data);
      }));
      output.pipe($(function(data, send) {
        if (data === 100) {
          inputs['add'].write(-10);
        }
        return send(data);
      })).pipe(D.$show());
      results = [];
      for (n = l = 1; l < 10; n = ++l) {
        results.push(input.write(n));
      }
      return results;
    })();
  };

  exec_and_eval_coffeescript = function() {
    var CS, VM, cs_source, definitions, js_source, local_filename, sandbox;
    CS = require('coffee-script');
    VM = require('vm');
    local_filename = 'myfile.js';
    definitions = new Map();
    sandbox = {
      d: 108,
      e: "a variable",
      urge: CND.get_logger('urge', '!!!'),
      help: CND.get_logger('help', '!!!'),
      define: function(pod) {
        var key, results, value;
        results = [];
        for (key in pod) {
          value = pod[key];
          results.push(definitions.set(key, value));
        }
        return results;
      }
    };
    sandbox['__sandbox'] = sandbox;
    VM.createContext(sandbox);
    cs_source = "urge \"helo from " + __filename + "\"\nurge Array\nd = 42\ndefine\n  x:      'some value'";
    js_source = CS.compile(cs_source, {
      bare: true
    });
    debug('©U4Zmb', VM.runInContext(js_source, sandbox, {
      filename: local_filename
    }));
    debug('©YMF7F', sandbox);
    return debug('©YMF7F', definitions);
  };

  caller_identity = function() {
    var caller, f, g;
    caller = null;
    f = function() {
      var results;
      debug('©YRo3i', arguments.callee);
      debug('©YRo3i', arguments.callee === caller_identity);
      debug('©YRo3i', arguments.callee === f);
      caller = arguments.callee.caller;
      results = [];
      while (caller != null) {
        debug('©1oA2s', caller.name, caller.length);
        results.push(caller = caller.caller);
      }
      return results;
    };
    g = function() {
      return f();
    };
    g();
    g();
    return g();
  };

  test_markdown_it_footnotes = function() {
    var MKTS, environment, md_parser, md_source;
    md_source = "Here is a footnote reference,[^1] and another,[^longnote]\nand a third[^3] one.\n\n[^1]: Here is the footnote.\n\n[^3]: Third footnote.\n\n[^longnote]: Here's one with multiple blocks.\n\n    Subsequent paragraphs are indented to show that they\nbelong to the previous footnote.\n\nHere is an inline note.^[Inlines notes are easier to write, since\nyou don't have to pick an identifier and move down to type the\nnote.]";
    MKTS = require('../jizura/lib/MKTS.js');
    md_parser = MKTS._new_markdown_parser();
    environment = {};
    urge(md_parser.parse(md_source, environment));
    return help(environment);
  };

  test_MKTS_raw_escaper = function() {
    var MKTS, md_parser, raw_command_pattern, raw_contents, raw_id_pattern, source;
    MKTS = require('../jizura/lib/MKTS.js');
    md_parser = MKTS._new_markdown_parser();
    this._escape_command_fences = function(text) {
      var R;
      R = text;
      R = R.replace(/♎/g, '♎0');
      R = R.replace(/☛/g, '♎a');
      R = R.replace(/☚/g, '♎b');
      R = R.replace(/\\<\\</g, '♎1');
      R = R.replace(/\\<</g, '♎2');
      R = R.replace(/<\\</g, '♎3');
      R = R.replace(/<</g, '♎4');
      return R;
    };
    this._unescape_command_fences_A = function(text) {
      var R;
      R = text;
      R = R.replace(/♎4/g, '<<');
      return R;
    };
    this._unescape_command_fences_B = function(text) {
      var R;
      R = text;
      R = R.replace(/♎3/g, '<<');
      R = R.replace(/♎2/g, '<<');
      return R = R.replace(/♎1/g, '<<');
    };
    this._unescape_command_fences_C = function(text) {
      var R;
      R = text;
      R = R.replace(/♎b/g, '☚');
      R = R.replace(/♎a/g, '☛');
      R = R.replace(/♎0/g, '♎');
      return R;
    };
    this._replace_raw_spans = function(source) {
      return source.replace(raw_command_pattern, (function(_this) {
        return function(_, raw_content) {
          var id;
          id = raw_contents.length;
          if (raw_content == null) {
            raw_content = '';
          }
          raw_content = _this._unescape_command_fences_A(raw_content);
          raw_content = _this._unescape_command_fences_B(raw_content);
          raw_content = _this._unescape_command_fences_C(raw_content);
          raw_contents.push(raw_content);
          return "☛" + id + "☚";
        };
      })(this));
    };
    raw_contents = [];
    source = "helo <<(raw>>first<<raw)>>\nhelo <<(code>>*world*<<code)>>\nhelo <<(raw>>do **not** parse this<<raw)>>\n<<(raw>><<raw)>>";
    raw_command_pattern = /(?:<<\(raw>><<raw\)>>)|(?:<<\(raw>>(.*?[^\\])<<raw\)>>)/g;
    raw_id_pattern = /☛([0-9]+)☚/g;
    source = this._escape_command_fences(source);
    debug(source = md_parser.render(source));
    help(source = this._replace_raw_spans(source));
    source = this._unescape_command_fences_A(source);
    source = this._unescape_command_fences_B(source);
    urge(raw_contents);
    source = source.replace(raw_id_pattern, (function(_this) {
      return function(_, id_txt) {
        var R, id;
        id = parseInt(id_txt, 10);

        /* TAINT check for existence */
        R = raw_contents[id];
        raw_contents[id] = 0;
        return R;
      };
    })(this));
    source = this._unescape_command_fences_C(source);
    return help(source);
  };

  MKTS_copy = function() {
    var MKTS, d, dd, meta, meta2;
    MKTS = require('/Volumes/Storage/io/jizura/src/MKTS.coffee');
    meta = {
      foo: 'bar'
    };
    d = [1, 2, 3, meta];
    dd = MKTS.copy(d);
    debug('©IcEM4', d, dd);
    debug('©IcEM4', d === dd);
    debug('©IcEM4', d[3] === dd[3]);
    meta2 = MKTS.copy(meta);
    debug('©LRVAf', meta, meta2);
    return debug('©LRVAf', meta === meta2);
  };

  find_duplicated_guides = function() {
    var $, D, input, output;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    input = njs_fs.createReadStream('/Volumes/Storage/io/jizura-datasources/data/5-derivatives/guide-pairs.txt');
    output = njs_fs.createWriteStream('/Volumes/Storage/io/jizura-datasources/data/5-derivatives/guide-pairs-duplicated.txt');
    return input.pipe(D.$split()).pipe($((function(_this) {
      return function(line, send) {
        if (line.length !== 0) {
          return send(line);
        }
      };
    })(this))).pipe($((function(_this) {
      return function(line, send) {
        if (!line.startsWith('#')) {
          return send(line);
        }
      };
    })(this))).pipe($((function(_this) {
      return function(line, send) {
        return send([line].concat(slice.call(line.split('\t'))));
      };
    })(this))).pipe($((function(_this) {
      return function(arg, send) {
        var _, glyph, guides, line;
        line = arg[0], _ = arg[1], guides = arg[2], glyph = arg[3];
        return send([line, glyph, guides]);
      };
    })(this))).pipe($((function(_this) {
      return function(fields, send) {
        var glyph, guides, line;
        line = fields[0], glyph = fields[1], guides = fields[2];
        if (!CND.isa_text(guides)) {
          warn(line, fields);
        }
        return send(fields);
      };
    })(this))).pipe($((function(_this) {
      return function(arg, send) {
        var glyph, guides, line;
        line = arg[0], glyph = arg[1], guides = arg[2];
        return send([line, glyph].concat(slice.call(Array.from(guides))));
      };
    })(this))).pipe($((function(_this) {
      return function(fields, send) {
        var glyph, guide_0, guide_1, line;
        line = fields[0], glyph = fields[1], guide_0 = fields[2], guide_1 = fields[3];
        if (!(guide_0 === '一' || guide_1 === '一')) {
          return send(fields);
        }
      };
    })(this))).pipe($((function(_this) {
      return function(fields, send) {
        var glyph, guide_0, guide_1, line;
        line = fields[0], glyph = fields[1], guide_0 = fields[2], guide_1 = fields[3];
        if (guide_0 === guide_1) {
          return send(fields);
        }
      };
    })(this))).pipe($((function(_this) {
      return function(arg, send) {
        var glyph, guide_0, guide_1, line;
        line = arg[0], glyph = arg[1], guide_0 = arg[2], guide_1 = arg[3];
        return send(line + '\n');
      };
    })(this))).pipe(output);
  };

  test_permutations = function() {
    var get_pairs;
    get_pairs = function(list) {

      /* TAINT allow or eliminate duplicates? */

      /* TAINT use all pairs and reversed pairs? */
      var R, i, j, key, l, length, m, ref, ref1, ref2, tuple;
      length = list.length;
      R = [];
      for (i = l = 0, ref = length - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        for (j = m = ref1 = i + 1, ref2 = length; ref1 <= ref2 ? m < ref2 : m > ref2; j = ref1 <= ref2 ? ++m : --m) {
          tuple = [list[i], list[j]];

          /* TAINT should be sorted acc to strokeorder / guide nr, not codepoint */
          tuple.sort();
          key = tuple.join('');
          if (indexOf.call(R, key) < 0) {
            R.push(key);
          }
          key = tuple[1] + tuple[0];
          if (indexOf.call(R, key) < 0) {
            R.push(key);
          }
        }
      }
      R.sort();
      return R;
    };
    help(get_pairs(['馬', '口', '冂', '口']));
    help(get_pairs(['馬', '口']));
    help(get_pairs(['馬']));
    return help(get_pairs([]));
  };

  test_require_coffee = function() {
    var CS, route, rqr_route, source;
    CS = require('coffee-script');
    route = '/Volumes/Storage/io/SCRATCH/load-with-absolute-path/options.coffee';
    debug('©SOE29', rqr_route = require.resolve(route));
    source = njs_fs.readFileSync(rqr_route, {
      encoding: 'utf-8'
    });
    debug('©jEOZd', CS.compile(source, {
      bare: true
    }));
    return debug('©U4Zmb', CS["eval"](source, {
      bare: true
    }));
  };

  test_chr = function() {
    var CHR;
    CHR = require('coffeenode-chr');
    debug('©K6tf7', CHR.as_rsg('&cdp#x8deb;', {
      input: 'xncr'
    }));
    debug('©K6tf7', CHR.as_rsg('&#x21b7a;', {
      input: 'xncr'
    }));
    return debug('©K6tf7', CHR.as_rsg('鿉', {
      input: 'xncr'
    }));
  };

  f = function() {
    var a, demofs, handler, ref;
    a = arguments.slice(0, arguments.length - 1);
    if (((!global['Reflect']) != null) || (((ref = global['Proxy']) != null ? ref['create'] : void 0) != null)) {

      /* https://github.com/tvcutsem/harmony-reflect */
      global['Reflect'] = require('harmony-reflect');
    }
    handler = {
      get: function(target, key) {
        warn('>>>', key);
        return target[key];
      }
    };
    demofs = new Proxy(require('./demofs'), handler);
    return null;
  };

  fix_remarkably = function() {
    process.chdir('/Volumes/Storage/io/remarkably');
    return debug('©pPhY8', require('.'));
  };

  try_lazy_require = function() {
    var D, name;
    D = {};
    Object.defineProperty(D, 'FOO', {
      get: function() {
        urge('XXXXXXX');
        return require('pipedreams');
      }
    });
    D.FOO = D.FOO;
    return debug('©x7Tof', (function() {
      var results;
      results = [];
      for (name in D.FOO) {
        results.push(name);
      }
      return results;
    })());
  };

  try_slicing_html = function() {
    var HOTMETAL, blocks_hotml, document_hotml, document_html;
    HOTMETAL = require('../hotmetal');
    document_html = "<p>some words</p>\n<p>b</p>\n<p></p>";
    document_hotml = HOTMETAL.HTML.parse(document_html);
    blocks_hotml = HOTMETAL.slice_toplevel_tags(document_hotml);
    urge('©l9k4h', HOTMETAL.as_html(document_hotml));
    debug('©l9k4h', blocks_hotml);
    debug('©l9k4h', blocks_hotml.length);
    return debug('©l9k4h', HOTMETAL.as_html(blocks_hotml[1]));
  };

  dynamic_buffer = function() {
    var buffer, error;
    buffer = new Buffer(3);
    buffer.fill(0);
    buffer.writeUIntBE(0xa1, 0, 1);
    buffer.writeUIntBE(0xa2, 1, 1);
    buffer.writeUIntBE(0xa3, 2, 1);
    try {
      buffer.writeUIntBE(0xa4, 3, 1);
    } catch (_error) {
      error = _error;
      debug('©FpHyj', rpr(error.prototype));
      debug('©FpHyj', rpr(error['message']));
      debug('©FpHyj', rpr(error['code']));
      throw error;
    }
    return debug('©zZZo2', buffer);
  };

  test_symbol_as_error = function() {
    var error, s;
    s = Symbol('xxx');
    try {
      throw s;
    } catch (_error) {
      error = _error;
      help(error);
      return help(error === s);
    }
  };

  test_hollerith_codec = function() {
    var CODEC, long_text;
    CODEC = require('/Volumes/Storage/io/hollerith-codec');
    debug('©sjAHS', CODEC.encode(['helo']));
    long_text = (new Array(1025)).join('#');
    return debug('©sjAHS', CODEC.encode(['foo', [long_text, long_text, long_text, long_text], 42]));
  };

  test_codepoints = function() {
    var chr, l, len, ref, results;
    ref = 'äö𪜀';
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      chr = ref[l];
      results.push(help(chr));
    }
    return results;
  };

  test_bloem = function() {
    var $, BLOOM, D, PSON, bloom_data, buffer, data, initialDictionary, njs_zlib, old_bloom, pson, settings, zlib_settings;
    D = require('pipedreams');
    $ = D.remit.bind(D);
    njs_zlib = require('zlib');
    PSON = require('pson');
    BLOOM = CND.BLOOM;
    settings = {
      size: 10
    };
    old_bloom = new BLOOM.new_filter(settings);
    BLOOM.add(old_bloom, new Buffer('helo world'));
    BLOOM.add(old_bloom, new Buffer('how are you'));
    BLOOM.report(old_bloom);
    help('©pOGr6', old_bloom);
    bloom_data = BLOOM.as_buffer(old_bloom);
    debug('©pOGr6', bloom_data.length);
    initialDictionary = ['foo'];
    pson = new PSON.ProgressivePair(initialDictionary);
    data = {
      "hello": "world!"
    };
    buffer = pson.toBuffer(JSON.stringify(old_bloom));
    debug('©Pmfq1', buffer);
    debug('©Pmfq1', buffer.length);
    urge('©RTDLw', pson.decode(buffer));
    zlib_settings = {
      level: njs_zlib.Z_NO_COMPRESSION
    };
    debug('©KdT6C', njs_zlib.deflateSync('helo'));
    debug('©KdT6C', njs_zlib.deflateSync('dddddddddddddddddddddddd'));
    debug('©KdT6C', (njs_zlib.deflateSync(bloom_data)).length);
    return debug('©KdT6C', (njs_zlib.deflateSync(bloom_data, zlib_settings)).length);
  };

  test_archiver = function() {
    var archive, archiver;
    archiver = require('archiver');
    archive = archiver.create('zip', {});
    archive.pipe($((function(_this) {
      return function(data, send) {
        whisper(rpr(data));
        return send(data);
      };
    })(this)));
    archive.on('end', (function(_this) {
      return function() {
        return help(archive.pointer());
      };
    })(this));
    archive.on('error', (function(_this) {
      return function(error) {
        throw error;
      };
    })(this));
    archive.append('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', {
      name: 'my-text'
    });
    return archive.finalize();
  };

  test_keys = function() {
    var db;
    this.create_facetstream = function(db, settings) {
      var arity, hi_hint, key, keys, lo_hint;
      lo_hint = null;
      hi_hint = null;
      if (settings != null) {
        keys = Object.keys(settings);
        switch (arity = keys.length) {
          case 1:
            switch (key = keys[0]) {
              case 'lo':
              case 'prefix':
                lo_hint = settings[key];
                break;
              case 'hi':
                hi_hint = settings[key];
                break;
              default:
                if (key !== 'prefix' && key !== 'lo' && key !== 'hi') {
                  throw new Error("unknown hint key " + (rpr(key)));
                }
            }
            break;
          case 2:
            keys.sort();
            if (keys[0] === 'hi' && keys[1] === 'lo') {
              lo_hint = settings['lo'];
              hi_hint = settings['hi'];
            } else if (keys[0] === 'prefix' && keys[1] === 'star') {
              lo_hint = settings['prefix'];
              hi_hint = settings['star'];
            } else {
              throw new Error("illegal hint keys " + (rpr(keys)));
            }
            break;
          default:
            throw new Error("illegal hint arity " + (rpr(arity)));
        }
      }
      return debug('©KaWp7', lo_hint, hi_hint);
    };
    db = null;
    this.create_facetstream(db);
    this.create_facetstream(db, {
      lo: ['bar']
    });
    this.create_facetstream(db, {
      hi: ['foo']
    });
    this.create_facetstream(db, {
      lo: ['bar'],
      hi: ['foo']
    });
    this.create_facetstream(db, {
      prefix: ['foo']
    });
    return this.create_facetstream(db, {
      prefix: ['foo'],
      star: '*'
    });
  };

  test_bloom_stream2 = function() {
    var $, Bloom, D, HOLLERITH, bloom, encode, idx, input, key, l, seen, ƒ;
    ƒ = CND.format_number;
    HOLLERITH = require('/Volumes/Storage/io/hollerith2');
    Bloom = require('bloom-stream');
    D = require('pipedreams');
    encode = function(data) {
      return new Buffer(JSON.stringify(data));
    };
    $ = D.remit.bind(D);

    /* Bloom.forCapacity(capacity, errorRate, seed, hashType, streamOpts) */
    bloom = Bloom.forCapacity(1e6, 0.01);
    seen = {};
    input = D.create_throughstream();
    input.pipe($(function(data, send) {
      seen[data] = 1;
      debug('©rAv0J', data);
      return send(data);
    })).pipe($(function(data, send) {
      return send(encode(data));
    })).pipe(bloom);
    bloom.on('finish', function*() {
      var color, d, idx, l, len, m, register, register_idx, registers, registers_bfr, s, t0, t1;
      for (idx = l = 0; l <= 20; idx = ++l) {
        d = bloom.has(encode(idx));
        color = d ? CND.green : CND.red;
        log(color(idx, d));
      }
      help("filter size: " + (ƒ((new Buffer(JSON.stringify(bloom["export"]()))).length)) + " bytes");
      registers = bloom["export"]()['registers'];
      for (register_idx = m = 0, len = registers.length; m < len; register_idx = ++m) {
        register = registers[register_idx];
        if (register == null) {
          registers[register_idx] = null;
        }
      }
      registers_bfr = HOLLERITH._encode_key(null, registers);
      help("filter size: " + (ƒ(registers_bfr.length)) + " bytes");
      help("1:1 storage size: " + (ƒ((new Buffer(JSON.stringify((function() {
        var results;
        results = [];
        for (s in seen) {
          results.push(s);
        }
        return results;
      })()))).length)) + " bytes");
      t0 = new Date();
      (yield leveldb.put('x', 'y'));
      t1 = new Date();
      debug('©8yyXq', t1 - t0);
    });
    for (idx = l = 0; l <= 10; idx = l += 3) {
      key = "abcdefghijklmnop/" + idx;
      input.write(key);
      debug('©0QQhI', 'd');
    }
    return input.end();
  };

  test_bloom_stream = function() {
    var $, Bloom, D, bloom, encode, idx, input, l;
    Bloom = require('bloom-stream');
    D = require('pipedreams');
    encode = function(data) {
      return new Buffer(JSON.stringify(data));
    };
    $ = D.remit.bind(D);

    /* Bloom.forCapacity(capacity, errorRate, seed, hashType, streamOpts) */
    bloom = Bloom.forCapacity(1e1, 1);
    input = D.create_throughstream();
    input.pipe($(function(data, send) {
      return send(encode(data));
    })).pipe(bloom);
    bloom.on('finish', function() {
      var color, d, idx, l;
      for (idx = l = 0; l <= 20; idx = ++l) {
        d = bloom.has(encode(idx));
        color = d ? CND.green : CND.red;
        log(color(idx, d));
      }
      debug('©fpWF8', bloom["export"]());
    });
    for (idx = l = 0; l <= 10; idx = l += 3) {
      input.write(idx);
    }
    return input.end();
  };

  g = function() {
    var test_todolist_tsort, test_tsort, test_yargs;
    test_yargs = function() {
      var argv;
      argv = require('yargs').usage('Usage: $0 <command> [options]').command("count", 'Count the lines in a file').command("foo", 'Foo the lines in a file').demand(1).example('$0 count -f foo.js', 'count the lines in the given file').demand('f').alias('f', 'file').nargs('f', 1).describe('f', 'Load a file').help('h').alias('h', 'help').epilog('copyright 2015').argv;
      return debug('©vRlET', argv);
    };
    test_yargs();
    test_todolist_tsort = function() {
      var TS, settings;
      TS = CND.TSORT;
      settings = {
        strict: true
      };
      g = TS.new_graph(settings);
      help((TS.link_down(g, 'buy food', 'cook')).join(' > '));
      help((TS.link_down(g, 'fetch money', 'buy food')).join(' > '));
      help((TS.link_down(g, 'do some reading', 'go to exam')).join(' > '));
      help((TS.link_down(g, 'cook', 'eat')).join(' > '));
      help((TS.link_down(g, 'go to bank', 'fetch money')).join(' > '));
      help((TS.link_down(g, 'fetch money', 'buy books')).join(' > '));
      help((TS.link_down(g, 'buy books', 'do some reading')).join(' > '));
      help((TS.link_down(g, 'go to market', 'buy food')).join(' > '));
      help();
      help((TS.link_down(g, 'buy food', 'go home')).join(' > '));
      help((TS.link_down(g, 'buy books', 'go home')).join(' > '));
      help((TS.link_down(g, 'go home', 'cook')).join(' > '));
      return help((TS.link_down(g, 'eat', 'go to exam')).join(' > '));
    };
    return test_tsort = function() {
      var TS, graph, matcher, nodes, settings;
      TS = CND.TSORT;
      settings = {
        strict: true,
        prefixes: ['f|', 'g|']
      };
      graph = TS.new_graph(settings);
      urge('1', TS.link(graph, 'id', '-', 'id'));
      urge('2', TS.link(graph, 'id', '>', '+'));
      urge('3', TS.link(graph, 'id', '>', '*'));
      urge('4', TS.link(graph, 'id', '>', '$'));
      urge('5', TS.link(graph, '+', '<', 'id'));
      urge('6', TS.link(graph, '+', '>', '+'));
      urge('7', TS.link(graph, '+', '<', '*'));
      urge('8', TS.link(graph, '+', '>', '$'));
      urge('9', TS.link(graph, '*', '<', 'id'));
      urge('10', TS.link(graph, '*', '>', '+'));
      urge('11', TS.link(graph, '*', '>', '*'));
      urge('12', TS.link(graph, '*', '>', '$'));
      urge('13', TS.link(graph, '$', '<', 'id'));
      urge('14', TS.link(graph, '$', '<', '+'));
      urge('15', TS.link(graph, '$', '<', '*'));
      urge('16', TS.link(graph, '$', '-', '$'));
      debug('©DE1h1', graph);
      help(nodes = TS.sort(graph));
      matcher = ['f|id', 'g|id', 'f|*', 'g|*', 'f|+', 'g|+', 'g|$', 'f|$'];
      if (!CND.equals(nodes, matcher)) {
        throw new Error("is: " + (rpr(nodes)) + "\nexpected:  " + (rpr(matcher)));
      }
      help(TS.get_precedences(graph));
      help(TS.precedence_of(graph, 'f|id'));
      help(TS.precedence_of(graph, 'f|$'));
      urge('1', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|+')));
      urge('2', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|*')));
      urge('3', (TS.precedence_of(graph, 'f|id')) > (TS.precedence_of(graph, 'g|$')));
      urge('4', (TS.precedence_of(graph, 'f|+')) < (TS.precedence_of(graph, 'g|id')));
      urge('5', (TS.precedence_of(graph, 'f|+')) > (TS.precedence_of(graph, 'g|+')));
      urge('6', (TS.precedence_of(graph, 'f|+')) < (TS.precedence_of(graph, 'g|*')));
      urge('7', (TS.precedence_of(graph, 'f|+')) > (TS.precedence_of(graph, 'g|$')));
      urge('8', (TS.precedence_of(graph, 'f|*')) < (TS.precedence_of(graph, 'g|id')));
      urge('9', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|+')));
      urge('10', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|*')));
      urge('11', (TS.precedence_of(graph, 'f|*')) > (TS.precedence_of(graph, 'g|$')));
      urge('12', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|id')));
      urge('13', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|+')));
      return urge('14', (TS.precedence_of(graph, 'f|$')) < (TS.precedence_of(graph, 'g|*')));
    };
  };


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  iterate_over_maps = function() {
    var d, k, list_from_iterator;
    list_from_iterator = function(iterator) {
      var R;
      R = [];
      for ( x of iterator ){ R.push( x ); };
      return R;
    };
    d = new Map();
    k = [1, 2];
    d.set(k, 42);
    d.set([1, 2], 33);
    debug('©ZUwOO', d.get(k));
    debug('©ZUwOO', d.get([1, 2]));
    CND.dir(d);
    debug('©g60BV', d.size);
    debug('©Vdchi', d.entries());
    debug('©Vdchi', d.entries().length);
    debug('©Vdchi', list_from_iterator(d.keys()));
    debug('©Vdchi', list_from_iterator(d.entries()));
    debug('©Vdchi', list_from_iterator(d.values()));
    debug('©KzfCH', d.keys());
    debug('©GreeH', typeof d.values());
    debug('©GreeH', CND.type_of(d.values()));
    debug('©GreeH', Object.prototype.toString.call(d.values()));
    return debug('©GreeH', Symbol.iterator);
  };

  test_xregexp3 = function() {

    /* See:
      https://github.com/loveencounterflow/xregexp3
      https://github.com/slevithan/xregexp/wiki/Roadmap
      https://gist.github.com/slevithan/2630353
      http://blog.stevenlevithan.com/archives/javascript-regex-and-unicode
     */
    var XRegExp, base_tokens_of, d, insert, match, matches, new_parse, parse, position, recognize_assignments, recognize_eos_mark, show, text, token_pattern, token_patterns, tokens, topmost_of;
    XRegExp = require('xregexp3');

    /* Always allow expressions like `\p{...}` to match beyond the Unicode BMP: */

    /* Always allow new extensions: */
    XRegExp.install('extensibility');
    token_patterns = [XRegExp("('{3}|\"{3}|\\p{L}+|\\p{Z}+|\\p{N}+|\\p{P}|\\p{S}|.+)")];
    insert = function(me, value, position, probe) {
      var R, arity;
      if (position == null) {
        position = 'last';
      }
      arity = arguments.length;
      switch (position) {
        case 'first':
          me.splice(0, 0, value);
          R = 0;
          break;
        case 'last':
          me.push(value);
          R = me.length - 1;
          break;
        case 'before':
        case 'after':
          if (arity !== 4) {
            throw new Error("expected 4 arguments, got " + arity);
          }
          R = me.indexOf(probe);
          if (!(R >= 0)) {
            throw new Error("unable to find " + (rpr(value)) + " in list");
          }
          me.splice(R, 0, value);
      }
      return R;
    };
    d = [];
    debug('©U08qy', insert(d, '+'));
    debug('©Gz6lh', insert(d, '*'));
    debug('©I23qn', insert(d, '-', 'before', '*'));
    debug('©U08qy', insert(d, '~'));
    debug('©BlRvr', d);
    topmost_of = function(stack) {
      return stack[stack.length - 1];
    };
    base_tokens_of = function(text) {
      var l, len, ref, results, t;
      ref = text.split(topmost_of(token_patterns));
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        t = ref[l];
        if (t !== '') {
          results.push(t);
        }
      }
      return results;
    };
    show = function(tokens) {
      var colors, i, t;
      colors = [CND.lime, CND.orange];
      log(((function() {
        var l, len, results;
        results = [];
        for (i = l = 0, len = tokens.length; l < len; i = ++l) {
          t = tokens[i];
          results.push(colors[i % 2](t.replace(/\s/g, '␣')));
        }
        return results;
      })()).join(' '));
      return null;
    };
    recognize_assignments = function(tokens) {
      var R, l, len, skip, token, token_idx;
      R = [];
      skip = 0;
      for (token_idx = l = 0, len = tokens.length; l < len; token_idx = ++l) {
        token = tokens[token_idx];
        if (skip > 0) {
          skip += -1;
          continue;
        }
        if (token.length > 1 && /:$/.test(token)) {
          R.push(token.slice(0, +(token.length - 2) + 1 || 9e9));
          R.push(token[token.length - 1]);
          continue;
        }
        R.push(token);
      }
      return R;
    };
    recognize_eos_mark = function(tokens) {
      var R, l, len, skip, token, token_idx;
      R = [];
      skip = 0;
      for (token_idx = l = 0, len = tokens.length; l < len; token_idx = ++l) {
        token = tokens[token_idx];
        if (skip > 0) {
          skip += -1;
          continue;
        }
        if (token.length > 1 && /;$/.test(token)) {
          R.push(token.slice(0, +(token.length - 2) + 1 || 9e9));
          R.push(token[token.length - 1]);
          continue;
        }
        R.push(token);
      }
      return R;
    };
    text = "helo 345world(d) '''34 great''' (,sw x";
    text = "d: foo/bar/$baz + /k += 3";
    text = "3+1*2*4+5";
    text = "foo: 34e3 + 1 ** +bar; baz: 42";
    tokens = base_tokens_of(text);
    show(tokens);
    tokens = recognize_assignments(tokens);
    show(tokens);
    tokens = recognize_eos_mark(tokens);
    show(tokens);
    position = 0;
    matches = [];
    match = null;
    token_pattern = topmost_of(token_patterns);
    while (match = XRegExp.exec(text, token_pattern, position, 'sticky')) {
      matches.push(match[1]);
      position = match.index + match[0].length;
    }
    show(matches);
    new_parse = require('tdop');
    parse = new_parse();
    help(parse('var a = 1 + 1;'));
    return urge(parse("var f = function(){};\nvar x = f(8);"));
  };

  f = function() {
    var isolate_content, match_newlines, parse_md, show_inherited_names, symbols_as_attributes, test_cs_lexer, test_error, test_gm, test_hummus, test_pdfinfo, test_regex_safeness, write_numbers;
    test_cs_lexer = function() {
      var Lexer, lexer, settings, source;
      Lexer = require('coffee-script/lib/coffee-script/lexer').Lexer;
      lexer = new Lexer();
      source = "f 'helo'";
      settings = {
        sourceMap: false
      };
      return debug('©2LYns', lexer.tokenize(source, settings));
    };
    test_cs_lexer();
    test_error = function() {
      var add_symbol, error, l, len, name, new_error, ref, x0, x1, y0, y1;
      require('es6-symbol/implement');
      x0 = Symbol('x');
      x1 = Symbol('x');
      y0 = Symbol["for"]('y');
      y1 = Symbol["for"]('y');
      debug('©s7yDl', x0 === x1);
      debug('©s7yDl', y0 === y1);
      this.codes = {};
      add_symbol = function(host, name) {
        var R;
        if ((R = host[name]) != null) {
          return R;
        }
        R = Symbol(name);
        host[name] = R;
        host[R] = name;
        return R;
      };
      new_error = function(host, code, message) {
        var R;
        R = new Error(message);
        code = add_symbol(host, code);
        R['code'] = code;
        return R;
      };
      ref = ['not implemented', 'division by zero'];
      for (l = 0, len = ref.length; l < len; l++) {
        name = ref[l];
        add_symbol(this, name);
      }
      error = this.new_error(this.codes, 'unknown name', "unknown name: 'xy'");
      debug('©c9Pf5', this.codes);
      debug('©c9Pf5', error);
      debug('©EDcXf', error['code']);
      debug('©EDcXf', error['code'] === this['codes']['unknown name']);
      throw error;
    };
    test_error();
    test_hummus = function() {
      var hummus;
      hummus = require('hummus');
      return 
    var pdfWriter = hummus.createWriterToModify(
                                         '/tmp/kwic-all-excerpts.pdf',
                                         {modifiedFilePath:'/tmp/kwic-all-excerpts-mod.pdf'});
    var pageModifier = new hummus.PDFPageModifier(pdfWriter,0);
    var cxt = pageModifier.startContext().getContext();
    cxt.drawCircle(
                  centerX,
                  centerY,
                  radius,
                  {
                      type:stroke,
                      width:1,
                      color:'black'
                  });
    pageModifier.endContext().writePage();
    pdfWriter.end();
    ;
    };
    test_hummus();
    show_inherited_names = function() {

      /* http://stackoverflow.com/a/8024294/256361 */
      var get_all_property_names;
      get_all_property_names = function(x) {
        var R, l, len, name, ref;
        R = [];
        while (true) {
          if (indexOf.call(R, name) < 0) {
            ref = Object.getOwnPropertyNames(x);
            for (l = 0, len = ref.length; l < len; l++) {
              name = ref[l];
              R.push(name);
            }
          }
          if ((x = Object.getPrototypeOf(x)) == null) {
            break;
          }
        }
        return R;
      };
      debug('©A3bXj', get_all_property_names([]));
      debug('©A3bXj', get_all_property_names([1, 2, 3]));
      debug('©qAxof', get_all_property_names({}));
      debug('©smLj8', get_all_property_names({
        'foo': 'bar'
      }));
      debug('©smLj8', {
        'foo': 'bar'
      }['constructor']);
      debug('©smLj8', (Object.getPrototypeOf({
        'foo': 'bar'
      })) != null);
      debug('©smLj8', Object.getOwnPropertyNames(Object.getPrototypeOf({
        'foo': 'bar'
      })));
      debug('©034vW', get_all_property_names(Object.create(null)));
      return CND.dir({});
    };
    show_inherited_names();
    test_gm = function() {
      var new_pdf, pdf, pdf_route;
      new_pdf = require('gm');
      pdf_route = '/Volumes/Storage/io/jizura-datasources/data/4-pdf/kwic-all.pdf';
      pdf = new_pdf(pdf_route);
      return pdf.identify(pdf_route, function(error, data) {
        if (error != null) {
          throw error;
        }
        return debug('©oP284', data);
      });
    };
    test_gm();
    test_pdfinfo = function() {
      var command, njs_cp, pattern, pdf_route;
      njs_cp = require('child_process');
      pdf_route = '/Volumes/Storage/io/jizura-datasources/data/4-pdf/kwic-all.pdf';
      command = "pdfinfo -meta " + pdf_route;
      pattern = /\nPages:\s+([0-9]+)\n/;
      return njs_cp.exec(command, function(error, stdout, stderr) {
        var match, page_count;
        if (error != null) {
          throw error;
        }
        warn(stderr);
        help(stdout);
        if ((match = stdout.match(pattern)) == null) {
          throw new Error("unable to read pdfinfo output " + (rpr(stdout)));
        }
        debug('©KJayE', rpr(match[1]));
        page_count = parseInt(match[1], 10);
        return debug('©1Dkzn', rpr(page_count));
      });
    };
    test_pdfinfo();
    test_regex_safeness = function() {

      /* https://github.com/substack/safe-regex */
      var matcher, probe, regex_is_safe;
      regex_is_safe = require('safe-regex');
      matcher = /^\n?‡(\S+?)\n$/;
      debug('©Md6b4', regex_is_safe(/(a+){10}/));
      debug('©Jdjoh', regex_is_safe(/^(\S+)\s+(.+)$/));
      debug('©6UvDi', regex_is_safe(matcher));
      probe = '\n‡abc\n';
      return debug('©32VzH', probe.match(matcher));
    };
    test_regex_safeness();
    process.exit();
    match_newlines = function() {
      var matcher, probe;
      matcher = /^\n?‡(\S+?)\n$/;
      probe = '\n‡abc\n';
      return debug('©32VzH', probe.match(matcher));
    };
    match_newlines();
    process.exit();
    isolate_content = function() {
      var matcher, register_intro_route, register_intro_tex;
      register_intro_route = '/Volumes/Storage/io/jizura-datasources/data/3-tex-generated/kwic-register-intro.tex';
      register_intro_tex = njs_fs.readFileSync(register_intro_route, 'utf-8');
      matcher = /^[\s\S]*\\begin\{document\}([\s\S]+)\\end\{document\}[\s\S]*$/;
      register_intro_tex = register_intro_tex.replace(matcher, '$1');
      return debug('©dJ32E', register_intro_tex);
    };
    isolate_content();
    process.exit();
    symbols_as_attributes = function() {
      var d, name, s, value;
      d = {
        foo: 42
      };
      s = Symbol('magic');
      debug('©RedP2', (Symbol('magic')) === (Symbol('magic')));
      debug('©RedP2', (Symbol["for"]('magic')) === (Symbol["for"]('magic')));
      d[s] = "it's magic";
      debug('©VbITC', rpr(d));
      debug('©VbITC', rpr(s));
      debug('©LFg8G', Object.keys(d));
      return debug('©LFg8G', (function() {
        var results;
        results = [];
        for (name in d) {
          value = d[name];
          results.push([name, value]);
        }
        return results;
      })());
    };
    symbols_as_attributes();
    process.exit();
    write_numbers = function() {
      var cid, cids, l, len, number, results;
      cids = [0x0020, 0x00A0, 0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x200B, 0x202F, 0x205F, 0x3000, 0xFEFF];
      number = "100'000'000'000'000'000'000'000'000'000'000'000'000'000'000'000'000";
      echo(number.replace(/'/g, ''));
      results = [];
      for (l = 0, len = cids.length; l < len; l++) {
        cid = cids[l];
        results.push(echo(number.replace(/'/g, String.fromCharCode(cid)), "0x" + (cid.toString(16))));
      }
      return results;
    };
    write_numbers();
    process.exit();
    parse_md = function() {
      var R, md, settings, source_references;
      settings = {
        html: true,
        linkify: false,
        breaks: false,
        langPrefix: 'codelang-',
        typographer: true,
        quotes: '“”‘’',
        source_references: true
      };
      source_references = require('coffeenode-markdown-it/lib/rules_core/source_references');
      R = (require('coffeenode-markdown-it'))(settings);
      R = R.use(source_references, {
        template: "<rf loc='${start},${stop}'></rf>"
      });
      md = "# hello\n\n<!--#123-->\n\nworld\n\nyet *another* paragraph\n\n```\nsome code\n```\n";

      /*
      { type: 'inline',
          content: 'world<!-- 123 -->',
          level: 1,
          lines: [ 2, 3 ],
          children:
           [ { type: 'text', content: 'world', level: 0 },
             { type: 'html_inline', content: '<!-- 123 -->', level: 0 } ] },
       */
      return help(R.render(md));
    };
    parse_md();
    return process.exit();
  };

}).call(this);
